function res = embed_message_mclt(carrier, message, params)

% EMBED_MESSAGE_MCLT - embed a message into a carrier signal using the
% given parameters.
%
%   signal_with_message = EMBED_MESSAGE_MCLT(carrier, message, params)
%       carrier - the audio signal (raw format) that will carry the data
%       message - a binary vector (zeros and ones) representing the message to be embedded
%       params  - a struct with the parameters for the embedding process generated by the set_params script
%
%   See also EXTRACT_MESSAGE_MCLT, SET_PARAMS

precompiledData = params.precompiledParametersForSpeedUp;
filename = params.theSoundFile;

if(precompiledData)
    mcltDataFileName = ['load ',filename,'Mclt.mat'];
    eval(mcltDataFileName);
else
    % extract often used params from params struct
    N = params.N;
    bands = [params.sync_bands, params.data_bands];
    sync_seq = params.sync_seq;
    code_len = params.code_len;
    code = params.code;

    % compute frequently used constants
    num_data_bands = length(params.data_bands);
    num_sync_bands = length(params.sync_bands);
    num_codes = num_data_bands/code_len;
    noblocks = floor(length(carrier)/N) - 1; % number of MCLT blocks in carrier signal
    even_noblocks = mod(noblocks,2) == 0;    % number of even MCLT blocks in carrier signal


    h=waitbar(0,'Transform to frequency domain ...');

    % transform to frequency domain (MCLT)
    MCLT = zeros(N,noblocks);
    for i=0:noblocks-1
        if(mod(i,1000))
            waitbar(i/noblocks)
        end
        idx = i*N+1:(i+2)*N;
        MCLT(:,i+1) = fmclt(carrier(idx));
    end
    close(h);
    %block selection decides what blocks are actually
    %used to embed data, it has impact on synch of closed caption
    block_selection = select_blocks(MCLT,params);

    res = zeros(size(carrier));
    if(params.cancel_interf)
        zs = compute_zs(bands,N);
        X_next = MCLT(:,2);
        idx = N+1:3*N;
        res(idx) = res(idx) + fimclt(X_next);
    end    
end


%%%%%% ===== embed data ====

if params.closed_caption_active
    [message,block_selection] = encodeSynchedMessage(params,block_selection);
    %TODO: handle zero padding
end
% apply crc and redundancy coding
message = encode_message(message, params);

% pad message with zeros if necessary
numbits = length(params.data_bands)/params.code_len*noblocks/2; %why divided by 2? because of noise canceling?
allBlocksAreTheSame = false;
if(length(message) == num_codes)
    allBlocksAreTheSame = true;
    message_len = length(carrier);
elseif(length(message) < numbits)
    message = [message; zeros(numbits-length(message),1)];
else
    message_len = length(message);
end

% change bit mapping of message (1->1, 0->-1)
message = 2*(message - 0.5);



% embed data into all but the first and the last blocks
msg_idx = 1;
if(params.cancel_interf)
    
    %progress bar
    h=waitbar(0,'Embedding message ...');
    
    for i = 3:2:noblocks-2
        %progress bar
        if(mod(i,1000))
            waitbar(i/noblocks)
        end
        % transform current and next block into MCLT domain
        idx = (i-1)*N+1:(i+1)*N;
        X_prev = X_next;
        X_curr = MCLT(:,i);
        X_next = MCLT(:,i+1);
        
        state = block_selection(i);
        
        % set configuration and sequence to be embedded depending on the current block
        % state == 0 -> block contains no data, skip it
        if(state == 2)
            % reference block
            correction = compute_interf_corr(params.data_bands,X_prev,X_curr,X_next,zs);
            ref_coeffs = X_curr(params.data_bands);
            X_curr(params.data_bands) = ref_coeffs - correction;
        elseif(state == 3)
            % start delimiter block
            seq = params.start_delimiter;
        elseif(state == -3)
            % end delimiter block
            seq = params.end_delimiter;
        elseif(state == 1)
            % data block
            if (allBlocksAreTheSame)
                seq = message;
            else
                seq = message(msg_idx:msg_idx+num_codes-1);
            end
            seq = kron(seq,code);
            msg_idx = msg_idx + num_codes;
        elseif(state == -1)
            % sync block with data
            if (allBlocksAreTheSame)
                seq = message;
            else
                seq = message(msg_idx:msg_idx+num_codes-1);
            end
            seq = kron(seq,params.sync_code);
            msg_idx = msg_idx + num_codes;
        end
        
        % embed sequence if the current block shall contain any
        if(mod(state,2) == 1)
            correction = compute_interf_corr(params.data_bands,X_prev,X_curr,X_next,zs);
            if(params.phase_coding_method == 2)
                % change phase differences between blocks according to sequence (0 for 1 and pi for -1)
                ref_coeffs(ref_coeffs == 0) = eps; % protect against division by zero
                ref_coeffs = ref_coeffs./abs(ref_coeffs).*abs(X_curr(params.data_bands)).*seq;
                X_curr(params.data_bands) = ref_coeffs - correction;
            elseif(params.phase_coding_method == 1)
                % change phase between frequencies according to sequence (0 for 1 and pi for -1)
                prev_coeff = X_curr(params.data_bands(1)-2);
                for j = 1:num_data_bands
                    k = params.data_bands(j);
                    if(prev_coeff == 0)
                        prev_coeff = 1;
                    end
                    prev_coeff = prev_coeff/abs(prev_coeff)*abs(X_curr(k))*seq(j);
                    X_curr(k) = prev_coeff - correction(j);
                end
            elseif(params.phase_coding_method == 0)
                % change phase according to sequence (0 for 1 and pi for -1)
                X_curr(params.data_bands) = abs(X_curr(params.data_bands)).*seq - correction;
            end
        end
        
        % compute inverse transform and add to result (overlap-add)
        res(idx) = res(idx) + fimclt(X_curr);
        res(idx+N) = res(idx+N) + fimclt(X_next);
    end
    close(h);
    % inverse transform and overlap-add of second last block in case of an
    % even number of blocks (missing in for loop)
    if(even_noblocks)
        idx = (noblocks-2)*N+1:noblocks*N;
        res(idx) = res(idx) + fimclt(MCLT(:,noblocks-1));
    end
else
    %progress bar
    h=waitbar(0,'Embedding message ...');
    
    for i = 1:noblocks-3
        %progress bar
        if(mod(i,1000))
            waitbar(i/noblocks)
        end
        % transform current and next block into MCLT domain
        idx = i*N+1:(i+2)*N;
        X_curr = MCLT(:,i+1);
        
        if(mod(i-1,params.sync_block_spacing) == 0)
            % sync data
            % borders
            k = params.sync_bands(1)-1;
            X_curr(k) = abs(X_curr(k));
            k = params.sync_bands(end)+1;
            X_curr(k) = abs(X_curr(k));
            
            for j = 1:num_sync_bands
                % change phase according to sequence (0 for 1 and pi for -1)
                k = params.sync_bands(j);
                X_curr(k) = abs(X_curr(k)) * sync_seq(j);
            end
        else
            % normal data
            % borders
            k = params.data_bands(1)-1;
            X_curr(k) = abs(X_curr(k));
            k = params.data_bands(end)+1;
            X_curr(k) = abs(X_curr(k));
            
            j = 1;
            while (msg_idx <= message_len && j <= num_data_bands)
                for m = 1:code_len
                    % change phase according to sequence (0 for 1 and pi for -1)
                    k = params.data_bands(j);
                    if(AllBlocksAreTheSame)
                        X_curr(k) = abs(X_curr(k)) * message(mod(msg_idx,num_codes)) * code(m);
                    else
                        X_curr(k) = abs(X_curr(k)) * message(msg_idx) * code(m);
                    end
                    j = j + 1;
                end
                msg_idx = msg_idx + 1;
            end
        end
        
        res(idx) = res(idx) + fimclt(X_curr); % add to result (overlap-add)
        
        if msg_idx > message_len
            break;
        end
    end
    close(h);
end

% overwrite first and last block with original carrier
res(1:N) = carrier(1:N);
res(end-N+1:end) = carrier(end-N+1:end);

end


function corr = compute_interf_corr(bands, X_prev, X_curr, X_next, zs)
%Compute interference cancellation
z_prev = squeeze(zs(1,bands,:));
z_next = squeeze(zs(2,bands,:));
corr = 2*1i*(z_prev*X_prev + (1/4)*X_curr(bands-1) - (1/4)*X_curr(bands+1) + z_next*X_next);
end


function zs = compute_zs(bands, N)
% Compute z-vectors for interference cancellation (array for lookup) (see paper)
% 1st dimension: i variable
% 2nd dimension: b variable
% 3rd dimension: l variable
zs = zeros(2,length(bands),N);
%progress bar
h=waitbar(0,'Compute z-vectors ...');
for idx =1:length(bands);
    k = bands(idx);
    %progress bar
    if(mod(idx,1000))
        waitbar(idx/length(bands));
    end
    for l=1:N
        abs_l_minus_k = abs(l-k);
        if(mod(abs_l_minus_k,2) == 0)
            m = abs_l_minus_k/2;
            tmp = (-1)^(l+m)/(2*pi*(2*m - 1)*(2*m + 1));
            zs(1,k,l) = tmp;
            zs(2,k,l) = (-1)*tmp;
        elseif (abs_l_minus_k == 1)
            zs(:,k,l) = (-1)^l/8;
        end
    end
end
close(h);
end

