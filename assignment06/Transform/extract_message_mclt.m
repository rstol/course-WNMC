function [message,plot_data] = extract_message_mclt(carrier, params)

% EXTRACT_MESSAGE_MCLT - extract a message from a carrier signal using the
% given parameters.
%
%   message = EXTRACT_MESSAGE_MCLT(carrier, params)
%       carrier     - the audio signal (raw format) carrying the data
%       params      - a struct with the parameters for the extraction process generated by the set_params script
%       message     - a binary vector (zeros and ones) representing the extracted message
%
%   See also EMBED_MESSAGE_MCLT, SET_PARAMS

% extract and compute often used params from params struct
N = params.N;
code = params.code;
sync_code = params.sync_code;
code_len = params.code_len;
data_bands = params.data_bands;
data_bands_len = length(data_bands);
sync_seq = params.sync_seq;
sync_len = length(sync_seq);
sync_bands = params.sync_bands;
codes_per_block = data_bands_len/code_len;

message = [];
carrier = carrier(800:end);

% sync receiver offset with transmitter (obsolete, better implementation in
% iOS app)
phase_refs = zeros(2*N,length(data_bands));
start = 10*N+1;
for i=start:start+params.sync_block_spacing*N-1
    idx = i:i+2*N-1;
    X = fmclt(carrier(idx));
    if(params.phase_coding_method == 1)
        % sync for subband relative phase coding
        x = X([data_bands(1)-params.block_spacing data_bands]);
        seq = -2*(abs(diff(unwrap(angle(x)))/pi)-0.5);
        code_matrix = reshape(seq,code_len,codes_per_block);
        sim_coeffs(i-start+1) = sum(abs(code'*code_matrix))/code_len;
%         sim_coeffs(i-start+1) = sum(2*abs((abs(diff(unwrap(angle(x))))/pi - 0.5)))/data_bands_len;
    elseif(params.phase_coding_method == 2)
        % sync for block relative phase coding
        X_ref = fmclt(carrier(idx-2*N));
        x = X(data_bands);
        x_ref = X_ref(data_bands);
        differences = abs(angle(x) - angle(x_ref));
        differences(differences > pi) = 2*pi - differences(differences > pi);
        seq = -2*(differences/pi-0.5);
        code_matrix = reshape(seq,code_len,codes_per_block);
        sim_coeffs(i-start+1) = sum(abs(code'*code_matrix))/code_len;
%         sim_coeffs(i-start+1) = sum(2*abs(differences/pi - 0.5))/data_bands_len;
        phase_refs(i-start+1,:) = x_ref;
    else
        if(params.cancel_interf)
            % sync for absolut phase coding (with interference cancellation)
            x = X(data_bands);
            seq = -2*(abs(angle(x)/pi) - 0.5);
            code_matrix = reshape(seq,code_len,codes_per_block);
            sim_coeffs(i-start+1) = sum(abs(code'*code_matrix))/code_len;
%             sim_coeffs(i-start+1) = sum(2*abs(abs(angle(x))/pi - 0.5))/sync_len;
        else
            % sync for absolut phase coding (without interference cancellation
            x = X(sync_bands);
            seq = sign(real(x));
            sim_coeffs(i-start+1) = (sync_seq'*seq)/sync_len;
        end
    end    
end

[sorted_sim_coeffs, sim_coeffs_order] = sort(sim_coeffs,'descend');
sorted_offsets = sim_coeffs_order + start - 1;

if(params.phase_coding_method == 2)
    sorted_phase_refs = phase_refs(sim_coeffs_order);
end

sum_coeffs = zeros(params.num_sync_coeffs,1);

% find best one of the offsets computed in the first run
for i=1:params.num_sync_coeffs
    sum_coeffs(i) = sorted_sim_coeffs(i);
    if(params.phase_coding_method == 2)
        x_ref = sorted_phase_refs(i);
    end
    for j=1:params.num_sync_runs-1
        idx = j*params.sync_block_spacing*N + sorted_offsets(i):(j*params.sync_block_spacing + 2)*N + sorted_offsets(i) - 1;
        X = fmclt(carrier(idx));
        if(params.phase_coding_method == 1)
            x = X([data_bands(1)-2 data_bands]);
            seq = -2*(abs(diff(unwrap(angle(x)))/pi)-0.5);
            code_matrix = reshape(seq,code_len,codes_per_block);
            sum_coeffs(i) = sum_coeffs(i) + sum(abs(code'*code_matrix))/code_len;
%             sum_coeffs(i) = sum_coeffs(i) + sum(2*abs((abs(diff(unwrap(angle(x))))/pi - 0.5)))/data_bands_len;
        elseif(params.phase_coding_method == 2)
            x = X(data_bands);
            differences = abs(angle(x) - angle(x_ref));
            differences(differences > pi) = 2*pi - differences(differences > pi);
            seq = -2*(differences/pi-0.5);
            code_matrix = reshape(seq,code_len,codes_per_block);
            sum_coeffs(i) = sum_coeffs(i) + sum(abs(code'*code_matrix))/code_len;
%             sum_coeffs(i) = sum_coeffs(i) + sum(2*abs(differences/pi - 0.5))/data_bands_len;
            x_ref = x;
        else
            if(params.cancel_interf)
                x = X(data_bands);
                seq = -2*(abs(angle(x)/pi) - 0.5);
                code_matrix = reshape(seq,code_len,codes_per_block);
                sum_coeffs(i) = sum_coeffs(i) + sum(abs(code'*code_matrix))/code_len;
%                 sum_coeffs(i) = sum_coeffs(i) + sum(2*abs(abs(angle(x))/pi - 0.5))/sync_len;
            else
                x = X(sync_bands);
                seq = sign(real(x));
                sum_coeffs(i) = sum_coeffs(i) + (sync_seq'*seq)/sync_len;
            end
        end
    end
end
[max_coeffs_sum,k] = max(sum_coeffs);
sorted_offsets = sorted_offsets - 1;
offset = mod(sorted_offsets(k),N);
sync_block_offset = mod(floor(sorted_offsets(k)/N),2);
disp(['block offset: ', num2str(offset)]);
disp(['Sync offset: ', num2str(sync_block_offset)]);
disp(['Max sync coefficient: ', num2str(max_coeffs_sum/codes_per_block/params.num_sync_runs)]);

carrier = carrier(1+offset:end);
noblocks = floor(length(carrier)/N)-1; %number of MCLT blocks in carrier signal

% initialize for data extration
start_block = sync_block_offset;
if(params.cancel_interf)
    start_block = start_block + 2;
end
if(params.phase_coding_method == 2)
    i = start_block;
    X_ref = fmclt(carrier(i*N+1:(i+2)*N));
    start_block = i + 2;
end
if(params.block_selection)
    state = 0;
else
    state = 1;
    delimiter_corr = 0;
end

% extract data from all but the first and the last blocks
for i = start_block:params.block_spacing:noblocks-2
    if(~params.cancel_interf && mod(i-1,params.sync_block_spacing) == mod(sync_block_offset-1,params.sync_block_spacing))
        continue; % skip sync blocks
    end
    
    idx = i*N+1:(i+2)*N;
    X = fmclt(carrier(idx)); % complex modulated lapped transform
    
    if(params.phase_coding_method == 2)
        % extract data for block relative phase coding
        x = X(data_bands);
        x_ref = X_ref(data_bands);
        differences = abs(angle(x) - angle(x_ref));
        differences(differences > pi) = 2*pi - differences(differences > pi);
        seq = -2*(differences/pi-0.5);        
        X_ref = X;
    elseif(params.phase_coding_method == 1)
        % extract data for subband relative phase coding
        x = X([data_bands(1)-2 data_bands]);
        seq = -2*(abs(diff(unwrap(angle(x)))/pi)-0.5);
    else
        % extract data for absolute phase coding
        x = X(data_bands);
        seq = -2*(abs(angle(x)/pi) - 0.5);
    end
    
    if(params.block_selection)
        delimiter_corr = seq'*params.start_delimiter/data_bands_len;
    end
    
    if(delimiter_corr > params.T3)
        % found start delimiter
        state = 1;
    elseif(delimiter_corr < -params.T3)
        % found end delimiter
        state = 0;
    elseif(state == 1)
        % decode data block
        for j=1:code_len:data_bands_len
            code_seq = seq(j:j+code_len-1)';
            corr_coeff = code_seq*code/code_len;
            msg_bit = corr_coeff > 0;
            message = [message; msg_bit, corr_coeff];
        end
    elseif(state == -1)
        % decode data/sync block
        for j=1:code_len:data_bands_len
            code_seq = seq(j:j+code_len-1)';
            corr_coeff = code_seq*sync_code/code_len;
            msg_bit = corr_coeff > 0;
            message = [message; msg_bit, corr_coeff];
        end
    end
end

if(params.redundancy_coding)
    % redundancy coding and crc (obsolete, better implementation in iOS
    % app)
    message = decode_message(message(:,2), params);
end

% generate data for plotting
plot_data = [];
if(params.make_plot)
    if(params.phase_coding_method == 2)
        X_ref2 = X_ref;
        X_ref2_prev = X_ref;
    end
    for i = params.plot_range_min+sync_block_offset:params.plot_range_max+sync_block_offset
        idx = i*N+1:(i+2)*N;
        X = fmclt(carrier(idx));
        
        if(params.phase_coding_method == 1)
            diffs = abs(angle(X(3:end)) - angle(X(1:end-2)));
            diffs(diffs > pi) = 2*pi - diffs(diffs > pi);
            plot_data = [plot_data diffs];
        elseif(params.phase_coding_method == 2)
            diffs = abs(angle(X)-angle(X_ref2_prev));
            diffs(diffs > pi) = 2*pi - diffs(diffs > pi);
            plot_data = [plot_data diffs];
            X_ref2_prev = X_ref2;
            X_ref2 = X;
        else
            plot_data = [plot_data angle(X)];
        end
    end
end

end
